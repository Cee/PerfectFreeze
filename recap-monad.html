 <!doctype html> <meta charset=utf-8> <title>重新理解 Monad · Perfect Freeze!</title> <meta name=viewport content="width=device-width,initial-scale=1"> <meta name=description content="对于大多数刚刚入门函数式编程的同学来说，monad（单子、又叫单体）可能是这里面的一道坎。你可能对 map、flatMap 以及 filter 再熟悉不过，可是到了高阶的抽象层次上就又会变得一脸懵逼。其实每个人在学习的阶段都会经历这个过程，不过希望这篇文章能让你重新理解 monad 以及其他相关的概念。"> <link rel=alternate href=/feed.xml type=application/atom+xml> <link rel=icon href=/favicon.ico> <link rel=apple-touch-icon href=/apple-touch-icon.png> <link rel=mask-icon href=/favicon.svg color=#ff00b4> <style>body,html{background:#fff}.content a,.navigation{font-weight:700}.content:after{clear:both}*,:after,:before{box-sizing:border-box;margin:0;padding:0}html{font-size:100%;-webkit-text-size-adjust:none;-ms-text-size-adjust:none;text-size-adjust:none;text-rendering:optimizelegibility;image-rendering:optimizequality}body{font-family:-apple-system,BlinkMacSystemFont,'Helvetica Neue','Hiragino Sans GB',Arial,sans-serif;font-size:1.6vw;line-height:1.42857143;margin:0 auto;padding:0 22vw;transition:all .2s ease;color:#000;font-feature-settings:'case','ss01','ss02'}@media (max-width:1080px){body{font-size:2.24vw;padding-right:8vw;padding-left:8vw}}@media (max-width:640px){body{font-size:3.84vw;padding-right:4vw;padding-left:4vw}}@media (max-width:400px){body{font-size:5.12vw}}a{transition:color .5s ease,border-color .5s ease,background .5s ease,opacity 1.5s ease;text-decoration:none;color:#000}a:focus,a:hover{transition:color .1s ease,border-color .1s ease,background .1s ease,opacity .1s ease;text-decoration:underline;-webkit-text-decoration-skip:ink;text-decoration-skip:ink}hr,img{border:0}::-moz-selection{background:rgba(108,181,252,.1)}::selection{background:rgba(108,181,252,.1)}::-webkit-input-placeholder{opacity:.2;color:#000}::-moz-placeholder{opacity:.2;color:#000}:-ms-input-placeholder{opacity:.2;color:#000}::placeholder{opacity:.2;color:#000}:focus::-webkit-input-placeholder{color:#6cb5fc}:focus::-moz-placeholder{color:#6cb5fc}:focus:-ms-input-placeholder{color:#6cb5fc}:focus::placeholder{color:#6cb5fc}.navigation{font-size:60%;margin-right:-1.1em;margin-left:-1.1em;padding-top:1.4vmax;padding-bottom:1.4vmax;letter-spacing:.45em;text-transform:uppercase}.navigation li{line-height:2;display:inline-block;list-style:none}.navigation li a{padding:.5em 1.2em}.navigation li a:focus,.navigation li a:hover{text-decoration:none;color:#6cb5fc}.content{margin-bottom:16vmin}.content:after,.content:before{display:table;content:''}.content article>:last-child,.content article>:last-child>:last-child,.content article>:last-child>:last-child>:last-child,.content article>:last-child>:last-child>:last-child>:last-child{margin-bottom:0!important}.content .post-content>:first-child,.content .post-content>:first-child>:first-child{margin-top:0}.content p{line-height:1.71428571;margin-bottom:1.6rem}.content header{display:-ms-flexbox;display:flex;flex-direction:column;min-height:calc(100vh - 5.6vmax - 5ex);margin-right:-22vw;margin-bottom:16vmin;margin-left:-22vw;background:rgba(0,0,0,.02);-ms-flex-direction:column;-ms-flex-pack:center;justify-content:center;padding:10vmin 22vw}@media (max-width:1080px){.content header{min-height:calc(64vh - 1.4vmax * 2 - 3ex);margin-right:-8vw;margin-left:-8vw;padding:16vmin 8vw}}@media (max-width:640px){.content header{margin-right:-4vw;margin-left:-4vw;padding-right:4vw;padding-left:4vw}}.content header h1{font-size:360%;font-weight:700;line-height:1.1;margin-left:-2px;letter-spacing:-.04em;-webkit-hyphens:none;hyphens:none;-webkit-font-smoothing:antialiased;-ms-hyphens:none}.content header small{display:block;margin-top:2vmin}.content h2{font-weight:400;margin:10vmin 0 1rem}.content ol,.content ul{margin-bottom:1.8rem;list-style:none;counter-reset:list}@media (max-width:640px){.content header h1{font-size:280%}.content ol,.content ul{margin-left:1em}}.content ol li,.content ul li{line-height:1.71428571}.content ol li:before,.content ul li:before{font-size:80%;line-height:2.14285714;position:absolute;display:inline-block;width:4em;margin-left:-4em;text-align:right;opacity:.6}.content ul li:before{padding-right:.6em;content:'•'}.content ol li:before{padding-right:.3em;content:counter(list) '.';counter-increment:list}.content img{display:block;width:calc(100% + (1.2vw * 2) + (2px * 2));margin:0 calc(-1.2vw - 2px) 1.8rem}@media (max-width:1080px){.content img{width:calc(100% + (8vw * 2));margin-right:-8vw;margin-left:-8vw}}@media (max-width:640px){.content img{width:calc(100% + (4vw * 2));margin-right:-4vw;margin-left:-4vw}}.content blockquote{font-size:90%;position:relative;margin-bottom:2.8rem;margin-left:calc(-1.2vw - 2px)}.content blockquote>p{margin-bottom:0;padding-bottom:1.6rem;padding-left:1.2vw;opacity:.6;border-left:2px solid}.content blockquote>p:last-of-type{margin-bottom:1.6rem;padding-bottom:0}@media (max-width:640px){.content blockquote{margin-left:0}.content blockquote>p{margin-right:-4vw;margin-left:-4vw;padding-right:4vw;padding-left:calc(4vw - 2px)}}.highlight .c1,.highlight .cm{font-style:italic}.content hr::before{content:'';display:block}.content hr::before{width:3px;height:3px;margin:2em auto;border-radius:50%;background:#000;box-shadow:24px 0 0 0 #000,-24px 0 0 0 #000}.content code,.content pre{font-family:Menlo,Consolas,monospace;color:#54c7fc}.content li code,.content p code{word-break:break-all}.content pre{font-size:80%;line-height:1.71428571;overflow-x:auto;margin-right:-1.2vw;margin-bottom:1.8rem;margin-left:-1.2vw;padding:1.2vw;background:rgba(0,136,255,.04);-webkit-overflow-scrolling:touch}@media (max-width:1080px){.content pre{margin-right:-8vw;margin-left:-8vw;padding-right:8vw;padding-left:8vw}}@media (max-width:640px){.content pre{margin-right:-4vw;margin-left:-4vw;padding-right:4vw;padding-left:4vw}}.footer{font-size:75%;padding:0 0 16vmin;text-transform:lowercase}.footer ul li{display:inline}.footer ul li:after{padding:0 .6vw;content:' / ';opacity:.3}.footer ul li:last-child:after{content:none}@media print{.content .post-content,img{max-width:100%!important}*,:after,:before{color:#000!important;background:0 0!important;box-shadow:none!important;text-shadow:none!important}body{margin:0!important;padding:10mm!important}a,a:visited{text-decoration:none}.content header{min-height:0;padding-bottom:0}.content .post-content a[href]:after{font-weight:400;content:' (' attr(href) ')'}blockquote,img,pre{page-break-inside:avoid}h2,p{orphans:3;widows:3}h2{page-break-after:avoid}.footer,.navigation{display:none}}.highlight .k,.highlight .kc,.highlight .kd,.highlight .kt,.highlight .nf,.highlight .o{font-weight:700}.highlighter-rouge .highlight{background:rgba(32,54,76,.02)}.highlight code{color:#b3b4b5}.highlight .n{color:#599ffc}.highlight .nf{color:#8d67fc}.highlight .nv{color:#c967fc}.highlight .k{color:#df8c76}.highlight .kc{color:#df9876}.highlight .kd{color:#dfa476}.highlight .kt{color:#dfd476}.highlight .mi{color:#59eec6}.highlight .o{color:#59e8fc}.highlight .p{color:#59cffc}.highlight .cm{opacity:.6;color:#b7a29c}.highlight .c1{opacity:.6;color:#8dbea9}.content h2{font-size:108%;opacity:.8}.navigation{text-align:center}</style> <link rel=canonical href=http://blog.cee.moe/recap-monad.html> <meta property=og:type content=article> <meta property=og:site_name content="Perfect Freeze!"> <meta property=og:title content="重新理解 Monad"> <meta property=og:url content=http://blog.cee.moe/recap-monad.html> <meta property=og:description content="对于大多数刚刚入门函数式编程的同学来说，monad（单子、又叫单体）可能是这里面的一道坎。你可能对 map、flatMap 以及 filter 再熟悉不过，可是到了高阶的抽象层次上就又会变得一脸懵逼。其实每个人在学习的阶段都会经历这个过程，不过希望这篇文章能让你重新理解 monad 以及其他相关的概念。"> <meta name=twitter:card content=summary> <meta name=twitter:title content="重新理解 Monad"> <meta name=twitter:url content=http://blog.cee.moe/recap-monad.html> <meta name=twitter:description content="对于大多数刚刚入门函数式编程的同学来说，monad（单子、又叫单体）可能是这里面的一道坎。你可能对 map、flatMap 以及 filter 再熟悉不过，可是到了高阶的抽象层次上就又会变得一脸懵逼。其实每个人在学习的阶段都会经历这个过程，不过希望这篇文章能让你重新理解 monad 以及其他相关的概念。"> <meta property=article:published_time content=2016-11-08T00:00:00+08:00> <meta property=article:modified_time content=2016-11-08T00:00:00+08:00> <meta name=twitter:label1 value=Words> <meta name=twitter:data1 value="1194 words"> <meta name=twitter:label2 value="Reading time"> <meta name=twitter:data2 value="5 mins"> <meta name=twitter:site content=@Ceecirno> <meta name=twitter:creator content=@Ceecirno> <nav class=navigation> <ul> <li> <a href=/ > Home </a> </li> <li> <a href=/articles/ > Articles </a> </li> <li> <a href=/works/ > Works </a> </li> <li> <a href=/friends/ > Friends </a> </li> <li> <a href=/about/ > About </a> </li> </ul> </nav> <main class=content role=main> <article> <header> <h1 title="重新理解 Monad" data-title="重新理解 Monad"> 重新理解 Monad<span class="dot dot--post"> </span> </h1> <small> By <span rel=author>Cee</span> on <time datetime=2016-11-08T00:00:00+08:00>Nov 8, 2016</time> </small> </header> <div class=post-content> <p>对于大多数刚刚入门函数式编程的同学来说，monad（单子、又叫单体）可能是这里面的一道坎。你可能对 <code class=highlighter-rouge>map</code>、<code class=highlighter-rouge>flatMap</code> 以及 <code class=highlighter-rouge>filter</code> 再熟悉不过，可是到了高阶的抽象层次上就又会变得一脸懵逼。其实每个人在学习的阶段都会经历这个过程，不过希望这篇文章能让你重新理解 monad 以及其他相关的概念。</p> <h2 id=optional>Optional</h2> <p>Swift 作为一门类型安全的强类型语言，它在编译阶段就会对你的数据类型进行比较多的检查。因此，在 Swift 中我们遇到了一种新的数据类型，叫做 <strong>Optional</strong>。它的定义如下：</p> <div class="language-swift highlighter-rouge"><pre class=highlight><code><span class=kd>public</span> <span class=kd>enum</span> <span class=kt>Optional</span><span class=o>&lt;</span><span class=kt>Wrapped</span><span class=o>&gt;</span> <span class=p>:</span> <span class=kt>ExpressibleByNilLiteral</span> <span class=p>{</span>
    <span class=k>case</span> <span class=k>none</span>
    <span class=k>case</span> <span class=nf>some</span><span class=p>(</span><span class=kt>Wrapped</span><span class=p>)</span>
<span class=p>}</span>
</code></pre> </div> <p>Optional 是个枚举类型，可以看到它有两个值：<code class=highlighter-rouge>none</code> 以及 <code class=highlighter-rouge>some</code>。简单点讲：</p> <blockquote> <p>值要么存在（presence），要么不存在（absence）。</p> </blockquote> <p>这也就意味着 Optional 可能是包含了一个某个类型的值（<code class=highlighter-rouge>some</code>），也可能是什么都没有（<code class=highlighter-rouge>none</code>）。在这里，Optional 就是个容器（<code class=highlighter-rouge>container</code>）。</p> <p><img src=https://ooo.0o0.ooo/2016/11/07/58204a65d8ad7.png alt="Optional Int"></p> <p>对于基础类型，在其后面直接加上 <code class=highlighter-rouge>?</code> 就代表了这就是个可选值类型（Optional value）。默认值即为 Optional 的预设值 <code class=highlighter-rouge>nil</code>（区别于 Objective-C）。</p> <p>判断一个可选值是否为空，我们通常会采用 <code class=highlighter-rouge>if let</code> 的写法来解包（wrap an optional）。</p> <div class="language-swift highlighter-rouge"><pre class=highlight><code><span class=k>if</span> <span class=k>let</span> <span class=nv>value</span> <span class=o>=</span> <span class=n>value</span> <span class=p>{</span>
    <span class=c1>// if value != nil</span>
<span class=p>}</span> <span class=k>else</span> <span class=p>{</span>
    <span class=c1>// value = nil</span>
<span class=p>}</span>
</code></pre> </div> <h2 id=map>Map</h2> <p>基础类型的 <code class=highlighter-rouge>map</code> 函数调用是非常简单的：</p> <div class="language-swift highlighter-rouge"><pre class=highlight><code><span class=k>let</span> <span class=nv>ages</span> <span class=o>=</span> <span class=p>[</span><span class=mi>20</span><span class=p>,</span> <span class=mi>40</span><span class=p>,</span> <span class=mi>50</span><span class=p>]</span>
<span class=k>let</span> <span class=nv>tripledAges</span> <span class=o>=</span> <span class=n>ages</span><span class=o>.</span><span class=n>map</span> <span class=p>{</span> <span class=nv>$0</span> <span class=o>*</span> <span class=mi>3</span> <span class=p>}</span>
<span class=c1>// tripledAges = [40, 80, 100]</span>
</code></pre> </div> <p>如果对于 Optional 呢？</p> <div class="language-swift highlighter-rouge"><pre class=highlight><code><span class=k>let</span> <span class=nv>price</span> <span class=o>=</span> <span class=kt>Optional</span><span class=p>(</span><span class=mi>20</span><span class=p>)</span>
<span class=k>let</span> <span class=nv>doubledPrice</span> <span class=o>=</span> <span class=n>price</span><span class=o>.</span><span class=n>map</span> <span class=p>{</span> <span class=nv>$0</span> <span class=o>*</span> <span class=mi>2</span> <span class=p>}</span>
<span class=c1>// doubledPrice = Optional(40)</span>

<span class=k>let</span> <span class=nv>nilPrice</span><span class=p>:</span> <span class=kt>Int</span><span class=p>?</span> <span class=o>=</span> <span class=o>.</span><span class=k>none</span> <span class=c1>// equals to `nil`</span>
<span class=k>let</span> <span class=nv>doubledNilPrice</span> <span class=o>=</span> <span class=n>nilPrice</span><span class=o>.</span><span class=n>map</span> <span class=p>{</span> <span class=nv>$0</span> <span class=o>*</span> <span class=mi>2</span> <span class=p>}</span>
<span class=c1>// doubledNilPrice = nil</span>
</code></pre> </div> <p>我们发现，<code class=highlighter-rouge>map</code> 函数作用在 Optional 上时：</p> <ul> <li>值存在（<code class=highlighter-rouge>.some</code>）：值类型 <code class=highlighter-rouge>Optional(Int)</code>，返回值类型 <code class=highlighter-rouge>Optional(Int)</code>；</li> <li>值不存在（<code class=highlighter-rouge>.none</code>）：返回值等同输入（<code class=highlighter-rouge>nil</code>）。</li> </ul> <hr> <p><code class=highlighter-rouge>map</code> 函数定义在 Optional 上，最大的好处就在于空值（<code class=highlighter-rouge>nil</code>）的处理，不需要我们再去使用 <code class=highlighter-rouge>if let</code> 解包（空值并没有乘法运算）：</p> <div class="language-swift highlighter-rouge"><pre class=highlight><code><span class=k>let</span> <span class=nv>nilPrice</span><span class=p>:</span> <span class=kt>Int</span><span class=p>?</span> <span class=o>=</span> <span class=o>.</span><span class=k>none</span> <span class=c1>// equals to `nil`</span>
<span class=k>var</span> <span class=nv>doubledNilPrice</span><span class=p>:</span> <span class=kt>Int</span><span class=p>?</span>

<span class=k>if</span> <span class=k>let</span> <span class=nv>nilPrice</span> <span class=o>=</span> <span class=n>nilPrice</span> <span class=p>{</span>
    <span class=n>doubledNilPrice</span> <span class=o>=</span> <span class=n>nilPrice</span> <span class=o>*</span> <span class=mi>2</span>
<span class=p>}</span> <span class=k>else</span> <span class=p>{</span>
    <span class=n>doubledNilPrice</span> <span class=o>=</span> <span class=kc>nil</span>
<span class=p>}</span>
</code></pre> </div> <p>因此：</p> <blockquote> <p><code class=highlighter-rouge>map</code> 只对值存在的可选值进行处理。</p> </blockquote> <p><code class=highlighter-rouge>map</code> 通常的表示方法：</p> <div class="language-swift highlighter-rouge"><pre class=highlight><code><span class=kd>func</span> <span class=n>map</span><span class=o>&lt;</span><span class=kt>U</span><span class=o>&gt;</span><span class=p>(</span><span class=n>_</span> <span class=nv>f</span><span class=p>:</span> <span class=p>(</span><span class=kt>T</span><span class=p>)</span> <span class=o>-&gt;</span> <span class=kt>U</span><span class=p>)</span> <span class=o>-&gt;</span> <span class=kt>Container</span><span class=p>(</span><span class=kt>U</span><span class=p>)</span>
</code></pre> </div> <p>在这里，容器 <code class=highlighter-rouge>Container</code> 就相当于 <code class=highlighter-rouge>Optional</code>，泛型 <code class=highlighter-rouge>T</code> 和 <code class=highlighter-rouge>U</code> 均为 <code class=highlighter-rouge>Int</code> 类型。在处理完 <code class=highlighter-rouge>Int</code> 值后 <code class=highlighter-rouge>map</code> 函数就把 <code class=highlighter-rouge>Int</code> 型转换成了 <code class=highlighter-rouge>Optional(Int)</code>，并返回。</p> <h2 id=async-callback-trouble>Async Callback Trouble</h2> <p>处理异步的网络请求是一件痛苦的事情。你一定碰到过：</p> <div class="language-swift highlighter-rouge"><pre class=highlight><code><span class=kd>typealias</span> <span class=kt>CompletionBlock</span> <span class=o>=</span> <span class=p>(</span><span class=n>_</span> <span class=nv>data</span><span class=p>:</span> <span class=kt>Data</span><span class=p>?,</span> <span class=n>_</span> <span class=nv>response</span><span class=p>:</span> <span class=kt>URLResponse</span><span class=p>?,</span> <span class=n>_</span> <span class=nv>error</span><span class=p>:</span> <span class=kt>Error</span><span class=p>?)</span> <span class=o>-&gt;</span> <span class=kt>Swift</span><span class=o>.</span><span class=kt>Void</span>

<span class=c1>// Callback</span>
<span class=k>if</span> <span class=n>error</span> <span class=o>!=</span> <span class=kc>nil</span> <span class=p>{</span> 
    <span class=cm>/* Dealing with network errors */</span> 
<span class=p>}</span>
<span class=k>if</span> <span class=k>let</span> <span class=nv>json</span> <span class=o>=</span> <span class=nf>parseToJSON</span><span class=p>(</span><span class=nv>with</span><span class=p>:</span> <span class=n>data</span><span class=p>)</span> <span class=p>{</span>
    <span class=cm>/* Dealing with parsing errors */</span> 
<span class=p>}</span>
<span class=cm>/* Dealing with JSON mapping errors */</span>
<span class=cm>/* Dealing with other errors */</span>
<span class=cm>/* WTF! 💩 Sh*t! */</span>
<span class=cm>/* Finally, with success */</span>
</code></pre> </div> <p>为什么我的异步回调就没有一种方式能够告诉我在哪里出错了呢？方案其实也很简单，我们先在定义一下异步处理的结果（<code class=highlighter-rouge>Result</code>）：</p> <div class="language-swift highlighter-rouge"><pre class=highlight><code><span class=kd>enum</span> <span class=kt>Result</span><span class=o>&lt;</span><span class=kt>T</span><span class=o>&gt;</span> <span class=p>{</span>
    <span class=k>case</span> <span class=nf>success</span><span class=p>(</span><span class=kt>T</span><span class=p>)</span>
    <span class=k>case</span> <span class=nf>failure</span><span class=p>(</span><span class=kt>Error</span><span class=p>)</span>
<span class=p>}</span>
</code></pre> </div> <p>有没有发现 <code class=highlighter-rouge>Result</code> 类型很像 <code class=highlighter-rouge>Optional</code>？没错。它能包含一个成功的返回值；也能在没有返回值时提供一个错误消息。</p> <hr> <p>我们也同时希望 <code class=highlighter-rouge>map</code> 能帮我们处理 <code class=highlighter-rouge>Result</code>：如果有结果，就从 <code class=highlighter-rouge>JSON</code> 转换到 <code class=highlighter-rouge>String</code>、再转换到其他类型；否则返回错误信息。</p> <p>这样的 <code class=highlighter-rouge>map</code> 函数怎么写呢？不妨先来看一下：</p> <div class="language-swift highlighter-rouge"><pre class=highlight><code><span class=kd>func</span> <span class=n>map</span><span class=o>&lt;</span><span class=kt>U</span><span class=o>&gt;</span><span class=p>(</span><span class=n>_</span> <span class=nv>f</span><span class=p>:</span> <span class=p>(</span><span class=kt>T</span><span class=p>)</span> <span class=o>-&gt;</span> <span class=kt>U</span><span class=p>)</span> <span class=o>-&gt;</span> <span class=kt>Result</span><span class=o>&lt;</span><span class=kt>U</span><span class=o>&gt;</span> <span class=p>{</span>
    <span class=k>switch</span> <span class=k>self</span> <span class=p>{</span>
    <span class=k>case</span> <span class=kd>let</span> <span class=o>.</span><span class=nf>success</span><span class=p>(</span><span class=n>value</span><span class=p>):</span>
        <span class=k>return</span> <span class=o>.</span><span class=nf>success</span><span class=p>(</span><span class=nf>f</span><span class=p>(</span><span class=n>value</span><span class=p>))</span>
    <span class=k>case</span> <span class=kd>let</span> <span class=o>.</span><span class=nf>failure</span><span class=p>(</span><span class=n>error</span><span class=p>):</span>
        <span class=k>return</span> <span class=o>.</span><span class=nf>failure</span><span class=p>(</span><span class=n>error</span><span class=p>)</span>
    <span class=p>}</span>
<span class=p>}</span>
</code></pre> </div> <p>举个最基本的例子，我们希望将返回的 <code class=highlighter-rouge>JSON</code> 转换成 <code class=highlighter-rouge>String</code>，那在这里，<code class=highlighter-rouge>map</code> 所接受的高阶变换 <code class=highlighter-rouge>f</code> 就是一个 <code class=highlighter-rouge>JSON -&gt; String</code> 的函数。调用时，<code class=highlighter-rouge>Result&lt;JSON&gt;</code> 就会通过 <code class=highlighter-rouge>map</code> 最终转换成 <code class=highlighter-rouge>Result&lt;String&gt;</code> 类型。</p> <p><img src=https://ooo.0o0.ooo/2016/11/07/5820b02a37f15.png alt=map></p> <p>看上去很不错！</p> <h2 id=functor>Functor</h2> <p>在了解 monad 之前，我们先来了解一下它的孪生兄弟：functor（函子）。</p> <p>从上面的例子中可以看到，在调用 <code class=highlighter-rouge>map</code> 函数后，我们还会把 <code class=highlighter-rouge>String</code> 类型的结果封装成了一个可选值 <code class=highlighter-rouge>Result&lt;String&gt;</code>。</p> <p>像这样能够从容器（Container，这里即 <code class=highlighter-rouge>Result</code>）中取出元素，并通过某个函数将其转换成可以再次被容器包装的结果的类型就称之为 functor。</p> <p>还有些不懂？没事，暂时就先记住有 functor 这么个玩意儿。</p> <h2 id=flatmap>FlatMap</h2> <p>重新回到之前 <code class=highlighter-rouge>JSON -&gt; String</code> 的例子上来。假设我们已经将某个 json 转换成了字符串，现在需要将字符串重新格式化，那我们应该需要再调用一次 <code class=highlighter-rouge>map</code>：</p> <div class="language-swift highlighter-rouge"><pre class=highlight><code><span class=kd>func</span> <span class=nf>map</span><span class=p>(</span><span class=n>_</span> <span class=nv>f</span><span class=p>:</span> <span class=kt>JSON</span> <span class=o>-&gt;</span> <span class=kt>Result</span><span class=o>&lt;</span><span class=kt>String</span><span class=o>&gt;</span><span class=p>)</span> <span class=o>-&gt;</span> <span class=kt>Result</span><span class=o>&lt;</span><span class=kt>Result</span><span class=o>&lt;</span><span class=kt>String</span><span class=o>&gt;&gt;</span>
</code></pre> </div> <p>不过我们多么希望返回的结果是个 <code class=highlighter-rouge>Result&lt;String&gt;</code> 的类型。不如写一个函数来解包带有两层的 <code class=highlighter-rouge>Result&lt;T&gt;</code>。</p> <div class="language-swift highlighter-rouge"><pre class=highlight><code><span class=kd>func</span> <span class=n>flatten</span><span class=o>&lt;</span><span class=kt>T</span><span class=o>&gt;</span><span class=p>(</span><span class=n>_</span> <span class=nv>f</span><span class=p>:</span> <span class=kt>Result</span><span class=o>&lt;</span><span class=kt>Result</span><span class=o>&lt;</span><span class=kt>T</span><span class=o>&gt;&gt;</span><span class=p>)</span> <span class=o>-&gt;</span> <span class=kt>Result</span><span class=o>&lt;</span><span class=kt>T</span><span class=o>&gt;</span> <span class=p>{</span>
    <span class=k>switch</span> <span class=n>f</span> <span class=p>{</span>
    <span class=k>case</span> <span class=kd>let</span> <span class=o>.</span><span class=nf>success</span><span class=p>(</span><span class=n>value</span><span class=p>):</span>
        <span class=k>return</span> <span class=n>value</span>
    <span class=k>case</span> <span class=kd>let</span> <span class=o>.</span><span class=nf>failure</span><span class=p>(</span><span class=n>error</span><span class=p>):</span>
        <span class=k>return</span> <span class=o>.</span><span class=nf>failure</span><span class=p>(</span><span class=n>error</span><span class=p>)</span>
    <span class=p>}</span>
<span class=p>}</span>
</code></pre> </div> <p>还有一点，在写 <code class=highlighter-rouge>flatten</code> 函数的时候，我们也同时考虑了在 <code class=highlighter-rouge>map</code> 函数中出现转换失败的问题。转换正确的时候的确我们的 <code class=highlighter-rouge>map</code> 的输出是个 <code class=highlighter-rouge>String</code> 类型的值，随之输出 <code class=highlighter-rouge>Result&lt;String&gt;</code> 进入下一层的 <code class=highlighter-rouge>map</code>；如果失败，则应当是被转换成 <code class=highlighter-rouge>.failure</code> 的结果。</p> <p>将 <code class=highlighter-rouge>map</code> 和 <code class=highlighter-rouge>flatten</code> 结合一下，我们就得到了所谓的 <code class=highlighter-rouge>flatMap</code>（又称作 <code class=highlighter-rouge>bind</code>）：</p> <div class="language-swift highlighter-rouge"><pre class=highlight><code><span class=kd>func</span> <span class=n>flatMap</span><span class=o>&lt;</span><span class=kt>U</span><span class=o>&gt;</span><span class=p>(</span><span class=n>_</span> <span class=nv>f</span><span class=p>:</span> <span class=p>(</span><span class=kt>T</span><span class=p>)</span> <span class=o>-&gt;</span> <span class=kt>Result</span><span class=o>&lt;</span><span class=kt>U</span><span class=o>&gt;</span><span class=p>)</span> <span class=o>-&gt;</span> <span class=kt>Result</span><span class=o>&lt;</span><span class=kt>U</span><span class=o>&gt;</span> <span class=p>{</span>
    <span class=k>return</span> <span class=nf>flatten</span><span class=p>(</span><span class=nf>map</span><span class=p>(</span><span class=n>f</span><span class=p>))</span>
<span class=p>}</span>
</code></pre> </div> <p><img src=https://ooo.0o0.ooo/2016/11/07/5820b02a72cf8.png alt=flatMap></p> <p>通过 <code class=highlighter-rouge>flatMap</code> 我们可以非常轻松地处理中途出现的错误异常，并对给定类型进行多次连续的类型转换。</p> <h2 id=monad>Monad</h2> <p>最后再来说什么是 monad。Chris Edihof 曾在他的文章中指出：</p> <blockquote> <p>如果可以为某个类型定义它的 <code class=highlighter-rouge>flatMap</code> 方法，那么这个类型通常就是个 <code class=highlighter-rouge>monad</code>。（If you can define <code class=highlighter-rouge>flatMap</code> for a type, the type is often called a <code class=highlighter-rouge>monad</code>.）</p> </blockquote> <p>在这里，我们通过 <code class=highlighter-rouge>map</code> 和 <code class=highlighter-rouge>flatten</code> 实现了 <code class=highlighter-rouge>Result</code> 类型的 <code class=highlighter-rouge>flatMap</code>。此时，我们就可以说 <code class=highlighter-rouge>Result</code> 这个类型就是一个 monad。</p> <h2 id=deal-with-monad>Deal with Monad</h2> <p>到现在你就可以非常轻松地处理你的异步请求了。</p> <div class="language-swift highlighter-rouge"><pre class=highlight><code><span class=kd>func</span> <span class=nf>toString</span><span class=p>(</span><span class=n>_</span> <span class=nv>data</span><span class=p>:</span> <span class=kt>Data</span><span class=p>)</span> <span class=o>-&gt;</span> <span class=kt>Result</span><span class=o>&lt;</span><span class=kt>String</span><span class=o>&gt;</span>
<span class=kd>func</span> <span class=nf>toInt</span><span class=p>(</span><span class=n>_</span> <span class=nv>str</span><span class=p>:</span> <span class=kt>String</span><span class=p>)</span> <span class=o>-&gt;</span> <span class=kt>Result</span><span class=o>&lt;</span><span class=kt>Int</span><span class=o>&gt;</span> 
<span class=kd>func</span> <span class=nf>toImage</span><span class=p>(</span><span class=n>_</span> <span class=nv>num</span><span class=p>:</span> <span class=kt>Int</span><span class=p>)</span> <span class=o>-&gt;</span> <span class=kt>Result</span><span class=o>&lt;</span><span class=kt>UIImage</span><span class=o>&gt;</span>
<span class=kd>func</span> <span class=nf>applyBlur</span><span class=p>(</span><span class=n>_</span> <span class=nv>image</span><span class=p>:</span> <span class=kt>UIImage</span><span class=p>)</span> <span class=o>-&gt;</span> <span class=kt>Result</span><span class=o>&lt;</span><span class=kt>UIImage</span><span class=o>&gt;</span>

<span class=c1>// WOW!</span>
<span class=nf>toString</span><span class=p>(</span><span class=n>data</span><span class=p>)</span>
    <span class=o>.</span><span class=nf>flatMap</span><span class=p>(</span><span class=n>toInt</span><span class=p>)</span>
    <span class=o>.</span><span class=nf>flatMap</span><span class=p>(</span><span class=n>toImage</span><span class=p>)</span>
    <span class=o>.</span><span class=nf>flatMap</span><span class=p>(</span><span class=n>applyBlur</span><span class=p>)</span>
</code></pre> </div> <h2 id=summary>Summary</h2> <ul> <li>重新回顾一下 <code class=highlighter-rouge>map</code> 和 <code class=highlighter-rouge>flatMap</code> 在 <code class=highlighter-rouge>Result&lt;T&gt;</code> 上的工作方式：</li> </ul> <p><img src=https://ooo.0o0.ooo/2016/11/07/5820b3639d4f0.jpg alt=map></p> <p><img src=https://ooo.0o0.ooo/2016/11/07/5820b3638931b.jpg alt=flatMap></p> <ul> <li>Functor、monad 可以看作是一种运算的抽象。它们的目的都是为了更好的解决类型的封装和转换。</li> </ul> <h2 id=further-reading>Further Reading</h2> <ul> <li>ReactiveCocoa</li> <li>Promise &amp; Future</li> <li>Swift 中的 <code class=highlighter-rouge>throw</code> 及 <code class=highlighter-rouge>rethrow</code></li> </ul> <h2 id=references>References</h2> <ol> <li><a href=http://www.javiersoto.me/post/106875422394>Functor and Monad in Swift - Javier Soto</a></li> <li><a href=http://www.infoq.com/cn/articles/swift-brain-gym-monad>Swift 烧脑体操（五）- Monad - 唐巧</a></li> <li><a href=https://realm.io/news/swift-tasks-nevyn-bengtsson>Monads Everywhere: Porting C#’s Tasks to Swift - Nevyn Bengtsson</a></li> <li><a href=http://chris.eidhof.nl/post/monads-in-swift/ >Monads in Swift - Chris Edihof</a></li> <li><a href=http://www.slideshare.net/UsrNameu1/swift-46430613>続・ゲンバのSwift</a></li> </ol> </div> </article> </main> <footer class=footer> <ul> <li><a href=/ >Perfect Freeze!</a></li> <li><a href=http://sparanoid.com/lab/amsf/ title="Almace Scaffolding">AMSF</a></li> <li><a href=http://sparanoid.com/lab/amsf/theme-curtana.html title=Curtana>Curtana</a></li> <li><a href=/feed.xml title="Feed - Atom (The Atom Syndication Format)">Atom</a></li> </ul> </footer> <script></script> <script></script> <script>!function(e,a,t,n,c,o,s){e.GoogleAnalyticsObject=c,e[c]=e[c]||function(){(e[c].q=e[c].q||[]).push(arguments)},e[c].l=1*new Date,o=a.createElement(t),s=a.getElementsByTagName(t)[0],o.async=1,o.src=n,s.parentNode.insertBefore(o,s)}(window,document,"script","//www.google-analytics.com/analytics.js","ga"),ga("create","UA-48656879-8","auto"),ga("send","pageview")</script> 